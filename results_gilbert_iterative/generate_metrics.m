function generate_metrics(results_dir, base_results_file, results_file_mask)
% GENERATE_METRICS(results_dir, base_results_file, results_file_mask)
%   This funciton generates a metrics file in each idv_N directory
%   Each idv_N directory must contain the results of the parametric sweep
%   of Gilbert channel mode state transition probabilities P and R.
%
% Rick Candell, 2014


    % specify 
    Nxmeas = 41; % use all xmeas variables
    
    if nargin < 3
        results_file_mask = '*.mat';
    end
    
    if nargin < 2
        error 'base results filename must be specified'
    end
    
    if nargin < 1
        results_dir = '.';
    end
    output_file_devmetrics = 'metrics_devs.csv';
    output_file_interror = 'metrics_interr.csv';
    
    % load the base IDV results
    if ~exist(results_dir,'dir')
        error 'results directory does not exist'
    end
    load([results_dir '\' base_results_file])
    BASE=RESULTS;
    Lxmeas = size(BASE.xmeas,1);
    clear RESULTS
    
    % write headers
    writeDevFileHdr(output_file_devmetrics);
    writeIntErrorFileHdr(output_file_interror);

    % loop through all files in the results directory
    mat_files = dir([results_dir '\' results_file_mask]);
    for ii=1:length(mat_files)
        this_file = mat_files(ii);
        load(this_file.name);
        
        % number of iterations for this scenario
        thisNit = size(RESULTS,2);
        
        % Gilbert channel probabilities
        P = RESULTS(1).P;
        R = RESULTS(1).R;
        IDVnum = RESULTS(1).IDVspec*pow2(0:19)';        
        
        % loop through all iterations
        for nn = 1:thisNit
            
            % create metrics structures for this iteration
            devMetrics = getDevMetricsStruct(P,R,IDVnum,nn);
            intErrMetrics = getIntegratedErrorStruct(P,R,IDVnum,nn);                
             
            % check if the plant shutdown
            thisShutdown = 0;
            thisLxmeas = size(RESULTS(nn).xmeas,1);
            if size(BASE.xmeas,1) ~= thisLxmeas
                thisShutdown = 1;
            end
            devMetrics.Shutdown = thisShutdown;
            intErrMetrics.Shutdown = thisShutdown;

            % calculate the integrated error metrics IAE and ITAE
            setpoints = getSetPoints();
                % IAE is just an ITAE with t=1 eveywhere
            intErrMetrics.iae  = calculateIAE(RESULTS(nn).Ts_save, ...
                RESULTS(nn).xmeas, setpoints);
                % IATE is the time weighted integrated absolute error
            intErrMetrics.itae = calculateITAE(RESULTS(nn).Ts_save, ...
                RESULTS(nn).xmeas, setpoints);
            
            % calculate the baseline integrated error metrics IAE and ITAE
                % IAE is just an ITAE with t=1 eveywhere
            intErrMetrics.iae_dev  = intErrMetrics.iae - calculateIAE(BASE.Ts_save, ...
                BASE.xmeas, setpoints);
                % IATE is the time weighted integrated absolute error
            intErrMetrics.itae_dev = intErrMetrics.itae - calculateITAE(BASE.Ts_save, ...
                BASE.xmeas, setpoints);            

            % calculate the deviation from base case
            thisDevs = calculateDeviations(BASE.xmeas, RESULTS(nn).xmeas);

            % measure the statistical deviations from base case measured
            % variables
            devMetrics.AvgDevs = mean(thisDevs, 1);
            devMetrics.MaxDevs = max(thisDevs, [], 1);
            devMetrics.VarDevs = var(thisDevs);

            % output vector for statistical quantities
            corr_metrics = zeros(1,Nxmeas);
            for jj = 1:Nxmeas
                % correlation between base case and the measured variable
                thisCorr = corr(BASE.xmeas(1:thisLxmeas,jj),RESULTS(nn).xmeas(:,jj));
                corr_metrics(jj) = thisCorr;
            end
            devMetrics.corr_metrics = corr_metrics;

            % metrics for baseline operating cost deviations
            devMetrics.OpCostCorr = corr(BASE.OpCost(1:thisLxmeas),RESULTS(nn).OpCost);     
            devMetrics.OpCostMaxDev = max(BASE.OpCost(1:thisLxmeas) - RESULTS(nn).OpCost);

            % metrics for quality compared to baseline
            devMetrics.QualityPctGspCorr = corr(BASE.Quality.signals.values(1:thisLxmeas,2),RESULTS(nn).Quality.signals.values(:,2));     
            devMetrics.QualityPctGspMaxDev = max(RESULTS(nn).Quality.signals.values(:,2) - BASE.Quality.signals.values(1:thisLxmeas,2));
            devMetrics.QualityPctGspVar = var(RESULTS(nn).Quality.signals.values(:,2) - BASE.Quality.signals.values(1:thisLxmeas,2));

            % write the stats to the output file
            writeDeviationMetrics(output_file_devmetrics, devMetrics);
            writeIntErrorMetrics(output_file_interror, intErrMetrics);
            
        end
    end
end % function

function thisDevs = calculateDeviations(base_xmeas, xmeas)
    thisLxmeas = size(xmeas,1);
    thisDevs = base_xmeas(1:thisLxmeas,:) - xmeas;
end

function str = getDevMetricsStruct(P,R,IDVnum,Iteration)
    str = struct( ...
        'P', P, ... 
        'R', R, ...
        'IDVnum', IDVnum, ...
        'Iteration', Iteration, ...
        'Shutdown', [], ...
        'AvgDevs', [], ...
        'MaxDevs', [], ...
        'VarDevs', [], ...
        'corr_metrics', [], ...
        'OpCostCorr', [], ...
        'OpCostMaxDev', [], ...
        'QualityPctGspCorr', [], ...
        'QualityPctGspMaxDev', [], ...
        'QualityPctGspVar', []);
end

function str = getIntegratedErrorStruct(P,R,IDVnum,Iteration)
    str = struct( ...
        'P', P, ... 
        'R', R, ...
        'IDVnum', IDVnum, ...
        'Iteration', Iteration, ...
        'Shutdown', [], ...
        'iae', [], ...
        'itae', [], ...
        'iae_dev', [], ...
        'itae_dev', [] );
end

function writeDeviationMetrics(output_file, metrics)
        dlmwrite(output_file, [ ...
            metrics.P ...
            metrics.R ...
            metrics.IDVnum ...
            metrics.Iteration, ...
            metrics.Shutdown ...
            metrics.AvgDevs ...
            metrics.MaxDevs ...
            metrics.VarDevs ...
            metrics.corr_metrics ...
            metrics.OpCostCorr ...
            metrics.OpCostMaxDev ...
            metrics.QualityPctGspCorr ...
            metrics.QualityPctGspMaxDev ...
            metrics.QualityPctGspVar], ...
            'delimiter',',','precision','%0.3f','-append');
end

function writeIntErrorMetrics(output_file, metrics)
        dlmwrite(output_file, [ ...
            metrics.P ...
            metrics.R ...
            metrics.IDVnum ...
            metrics.Iteration, ...
            metrics.Shutdown ...
            metrics.iae , ...
            metrics.itae, ...
            metrics.iae_dev , ...
            metrics.itae_dev], ...
            'delimiter',',','precision','%0.3f','-append');
end

function writeIntErrorFileHdr(output_file)
    % domain indicators
    domain_names = {'P','R','IDVnum','Iteration'};
    
    % shutdown metrics
    shutdown_name = {'Shutdown'};    
    
    % Average error metrics for the set-point-driven measured variables
    iae_names_template = {'Production','Stripper Level','Separator Level','Reactor Level', ...
        'Reactor Pressure','Reactor Temp','Molar_Pct_G'};
    iae_names = strcat({'IAE '}, iae_names_template);
    itae_names = strcat({'ITAE '}, iae_names_template);    
    iae_names_dev = strcat({'DEV IAE '}, iae_names_template);
    itae_names_dev = strcat({'DEV ITAE '}, iae_names_template);        
    % create the header
    hdr = strjoin( ...
        [ domain_names ...
        shutdown_name ...
        iae_names ...
        itae_names ...
        iae_names_dev ...
        itae_names_dev],',');
    fid = fopen(output_file,'w');
    fprintf(fid,[hdr '\n']);
    fclose(fid);    
end

function writeDevFileHdr(output_file)
    % domain indicators
    domain_names = {'P','R','IDVnum','Iteration'};
    
    % shutdown metrics
    shutdown_name = {'Shutdown'};    
    
    % deviation metrics
    avg_names =  strcat({'AVGDEV from '}, getXMeasNames(1:41));
    max_names =  strcat({'MAXDEV from '}, getXMeasNames(1:41));
    
    % variance metrics
    var_names =  strcat({'VAR from '}, getXMeasNames(1:41));
    corr_names = strcat({'CORR of '}, getXMeasNames(1:41));
    
    % cost metrics
    opcost_names = {'Corr_to_OpCost', 'MaxDev_from_OpCost'};
    quality_name = {'Corr_to_PctG', 'MaxDev_from_PctG', 'Var_from_PctG'};
    
    % create the header
    hdr = strjoin( ...
        [ domain_names ...
        shutdown_name ...
        avg_names ...
        max_names ...
        var_names ...
        corr_names ...
        opcost_names ...
        quality_name ],',');
    fid = fopen(output_file,'w');
    fprintf(fid,[hdr '\n']);
    fclose(fid);
end

function names = getXMeasNames(idx)
    names = { ...
        'A feed stream 1', ...
        'D feed stream 2', ...
        'E feed stream 3', ...
        'A and C feed stream 4', ...
        'Recycle flow Stream 8', ...
        'Reactor feed rate stream 6', ...
        'Reactor pressure', ...
        'Reactor level', ...
        'Reactor temperature', ...
        'Purge rate stream 9', ...
        'Product separator temperature ', ...
        'Product separator level', ...
        'Product separator pressure', ...
        'Product separator underflow stream 10', ...
        'stripper level', ...
        'stripper pressure', ...
        'Stripper underflow stream 11', ...
        'stripper temperature', ...
        'strippx steam dew', ...
        'Compressor work', ...
        'Reactor cooling water outlet temperature', ...
        'separator cooling water outlet temperature', ...
        'Reactor feed A', ...
        'Reactor feed B', ...
        'Reactor feed C', ...
        'Reactor feed D', ...
        'Reactor feed E', ...
        'Reactor feed F', ...
        'Purge gas A', ...
        'Purge gas B', ...
        'Purge gas C', ...
        'Purge gas D', ...
        'Purge gas E', ...
        'Purge gas F', ...
        'Purge gas G', ...
        'Purge gas H', ...
        'Product D', ...
        'Product E', ...
        'Product F', ...
        'Product G', ...
        'Product H' };
    names = names(idx);
end

function idx = getIAEIndicies()
    idx = [ ...
        17 ...                  % production
        15 ...                  % strip level
        12 ...                  % Sep. level
        8 ...                   % Reactor level
        7 ...                   % Reactor pressure
        9 ...                   % Reactor temp
        40 ];                   % Mol % G;                    
end

function sp = getSetPoints()
    sp = [ ...
        22.89 ...                   % production
        50 ...                      % strip level
        50 ...                      % Sep. level
        65 ...                      % Reactor level
        2800 ...                    % Reactor pressure
        122.9 ...                   % Reactor temp 
        53.8 ];                     % Mol % G
end

function iae = calculateIAE(Ts, xmeas, setpoints)
    Nx = size(xmeas,1);
    sp = repmat(setpoints,Nx,1);
    idx = getIAEIndicies();
    w = ones(1,Nx);
    iae = T_IntegratedError(Ts, w, xmeas(:,idx), sp);
end

function itae = calculateITAE(Ts, xmeas, setpoints)
    Nx = size(xmeas,1);
    sp = repmat(setpoints,Nx,1);
    idx = getIAEIndicies();
    w = (0:Nx-1)*Ts;
    itae = T_IntegratedError(Ts, w, xmeas(:,idx), sp);
end

function err_metric = T_IntegratedError(Ts, w, xmeas, sp)
    err_metric = (w(:).')*abs(xmeas-sp)*Ts;    
end




